<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> bort</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-image: url('F.png');
            background-size: 120% 120%;
            /* تكبير الصورة بنسبة 120% */
            background-position: center center;
            background-repeat: no-repeat;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: relative;
        }

        /* إضافة فلتر أصفر للخلفية بالكامل */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 0, 0.15);
            mix-blend-mode: overlay;
            z-index: 0;
            pointer-events: none;
        }

        /* إضافة طبقة توهج صفراء للخلفية */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255, 255, 100, 0.3) 0%, rgba(255, 200, 50, 0.2) 60%, rgba(255, 150, 30, 0.1) 100%);
            z-index: 1;
            pointer-events: none;
        }

        /* إضافة طبقة لامعة صفراء متحركة */
        body::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg,
                    rgba(255, 255, 100, 0) 0%,
                    rgba(255, 255, 100, 0.05) 25%,
                    rgba(255, 255, 100, 0.1) 50%,
                    rgba(255, 255, 100, 0.05) 75%,
                    rgba(255, 255, 100, 0) 100%);
            z-index: 2;
            pointer-events: none;
            animation: shimmer 8s infinite linear;
        }

        @keyframes shimmer {
            0% {
                background-position: -100% -100%;
            }

            100% {
                background-position: 200% 200%;
            }
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            /* المجسم في المرتبة الثانية */
            /* ضمان أن المحتوى يظهر فوق طبقات الخلفية */
        }

        #logo {
            position: absolute;
            top: 30px;
            bottom: auto;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            /* EVE في المرتبة الثالثة (الأدنى) */
            text-align: center;
        }

        #logo h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 9.5rem;
            letter-spacing: 0.8rem;
            margin: 0;
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0.95),
                    rgba(230, 230, 230, 0.9),
                    rgba(200, 200, 200, 0.8),
                    rgba(170, 170, 170, 0.7));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow:
                0 0 5px rgba(255, 255, 255, 0.8),
                0 0 10px rgba(240, 240, 240, 0.7),
                0 0 15px rgba(220, 220, 220, 0.6),
                0 0 20px rgba(200, 200, 200, 0.5),
                0 0 35px rgba(180, 180, 180, 0.4),
                0 0 45px rgba(160, 160, 160, 0.3);
            animation: textGlow 3s infinite alternate;
            position: relative;
        }

        /* تأثير توهج النص على شكل نبضات */
        @keyframes textGlow {

            0%,
            100% {
                text-shadow:
                    0 0 5px rgba(255, 255, 255, 0.8),
                    0 0 10px rgba(240, 240, 240, 0.7),
                    0 0 15px rgba(220, 220, 220, 0.6),
                    0 0 20px rgba(200, 200, 200, 0.5),
                    0 0 35px rgba(180, 180, 180, 0.4),
                    0 0 45px rgba(160, 160, 160, 0.3);
            }

            50% {
                text-shadow:
                    0 0 10px rgba(255, 255, 255, 0.9),
                    0 0 20px rgba(240, 240, 240, 0.8),
                    0 0 30px rgba(220, 220, 220, 0.7),
                    0 0 40px rgba(200, 200, 200, 0.6),
                    0 0 70px rgba(180, 180, 180, 0.5),
                    0 0 90px rgba(160, 160, 160, 0.4);
            }
        }

        /* إضافة خطوط ضوئية خلف النص */
        #logo h1::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 150%;
            transform: translate(-50%, -50%);
            background: radial-gradient(ellipse at center,
                    rgba(255, 255, 255, 0.3) 0%,
                    rgba(240, 240, 240, 0.2) 40%,
                    rgba(220, 220, 220, 0.1) 60%,
                    rgba(200, 200, 200, 0) 80%);
            z-index: -1;
            opacity: 0.7;
            filter: blur(5px);
            animation: glowPulse 3s infinite alternate;
        }

        @keyframes glowPulse {

            0%,
            100% {
                opacity: 0.5;
                filter: blur(5px);
            }

            50% {
                opacity: 0.8;
                filter: blur(8px);
            }
        }

        /* تأثير وميض النص - تم استبداله بالتأثير الجديد أعلاه */
        @keyframes textFlicker {

            0%,
            18%,
            22%,
            25%,
            53%,
            57%,
            100% {
                text-shadow:
                    0 0 5px rgba(120, 220, 255, 0.7),
                    0 0 10px rgba(120, 220, 255, 0.5),
                    0 0 15px rgba(120, 220, 255, 0.3),
                    0 0 20px rgba(120, 220, 255, 0.2);
            }

            20%,
            24%,
            55% {
                text-shadow: none;
            }
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        #button-container {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 300;
            /* الأزرار في المرتبة الأولى (الأعلى) */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: auto;
            pointer-events: auto;
        }

        #icons-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 15px;
            flex-wrap: wrap;
            width: 100%;
            pointer-events: auto;
            z-index: 310;
            /* مستوى أعلى من حاوية الأزرار */
        }

        button {
            all: unset;
            cursor: pointer;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
            position: relative;
            border-radius: 999vw;
            background-color: rgba(0, 0, 0, 0.75);
            box-shadow: -0.15em -0.15em 0.15em -0.075em rgba(5, 5, 5, 0.25),
                0.0375em 0.0375em 0.0675em 0 rgba(5, 5, 5, 0.1);
            margin: 5px;
            pointer-events: auto;
            z-index: 320;
            /* أعلى مستوى للأزرار نفسها */
        }

        button::after {
            content: "";
            position: absolute;
            z-index: 0;
            width: calc(100% + 0.3em);
            height: calc(100% + 0.3em);
            top: -0.15em;
            left: -0.15em;
            border-radius: inherit;
            background: linear-gradient(-135deg,
                    rgba(5, 5, 5, 0.5),
                    transparent 20%,
                    transparent 100%);
            filter: blur(0.0125em);
            opacity: 0.25;
            mix-blend-mode: multiply;
        }

        button .button-outer {
            position: relative;
            z-index: 1;
            border-radius: inherit;
            transition: box-shadow 300ms ease;
            will-change: box-shadow;
            box-shadow: 0 0.05em 0.05em -0.01em rgba(5, 5, 5, 1),
                0 0.01em 0.01em -0.01em rgba(5, 5, 5, 0.5),
                0.15em 0.3em 0.1em -0.01em rgba(5, 5, 5, 0.25);
        }

        button:hover .button-outer {
            box-shadow: 0 0 0 0 rgba(5, 5, 5, 1), 0 0 0 0 rgba(5, 5, 5, 0.5),
                0 0 0 0 rgba(5, 5, 5, 0.25);
        }

        .button-inner {
            --inset: 0.035em;
            position: relative;
            z-index: 1;
            border-radius: inherit;
            padding: 1em 1.5em;
            background-image: linear-gradient(135deg,
                    rgba(230, 230, 230, 1),
                    rgba(180, 180, 180, 1));
            transition: box-shadow 300ms ease, clip-path 250ms ease,
                background-image 250ms ease, transform 250ms ease;
            will-change: box-shadow, clip-path, background-image, transform;
            overflow: clip;
            clip-path: inset(0 0 0 0 round 999vw);
            box-shadow:
                /* 1 */
                0 0 0 0 inset rgba(5, 5, 5, 0.1),
                /* 2 */
                -0.05em -0.05em 0.05em 0 inset rgba(5, 5, 5, 0.25),
                /* 3 */
                0 0 0 0 inset rgba(5, 5, 5, 0.1),
                /* 4 */
                0 0 0.05em 0.2em inset rgba(255, 255, 255, 0.25),
                /* 5 */
                0.025em 0.05em 0.1em 0 inset rgba(255, 255, 255, 1),
                /* 6 */
                0.12em 0.12em 0.12em inset rgba(255, 255, 255, 0.25),
                /* 7 */
                -0.075em -0.25em 0.25em 0.1em inset rgba(5, 5, 5, 0.25);
        }

        button:hover .button-inner {
            clip-path: inset(clamp(1px, 0.0625em, 2px) clamp(1px, 0.0625em, 2px) clamp(1px, 0.0625em, 2px) clamp(1px, 0.0625em, 2px) round 999vw);
            box-shadow:
                /* 1 */
                0.1em 0.15em 0.05em 0 inset rgba(5, 5, 5, 0.75),
                /* 2 */
                -0.025em -0.03em 0.05em 0.025em inset rgba(5, 5, 5, 0.5),
                /* 3 */
                0.25em 0.25em 0.2em 0 inset rgba(5, 5, 5, 0.5),
                /* 4 */
                0 0 0.05em 0.5em inset rgba(255, 255, 255, 0.15),
                /* 5 */
                0 0 0 0 inset rgba(255, 255, 255, 1),
                /* 6 */
                0.12em 0.12em 0.12em inset rgba(255, 255, 255, 0.25),
                /* 7 */
                -0.075em -0.12em 0.2em 0.1em inset rgba(5, 5, 5, 0.25);
        }

        button .button-inner span {
            position: relative;
            z-index: 4;
            font-family: "Inter", sans-serif;
            letter-spacing: -0.05em;
            font-weight: 500;
            color: rgba(0, 0, 0, 0);
            background-image: linear-gradient(135deg,
                    rgba(230, 230, 230, 1),
                    rgba(255, 255, 255, 1));
            -webkit-background-clip: text;
            background-clip: text;
            transition: transform 250ms ease;
            display: block;
            will-change: transform;
            text-shadow: rgba(255, 255, 255, 0.2) 0 0 0.1em;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            font-size: 0.8rem;
        }

        /* إضافة تنسيق خاص للزر الرئيسي */
        #copy-button .button-inner {
            background-image: linear-gradient(135deg,
                    rgba(50, 50, 50, 1),
                    rgba(25, 25, 25, 1));
        }

        .icon-btn .button-inner {
            padding: 0.7em 1em;
            background-image: linear-gradient(135deg,
                    rgba(255, 200, 50, 1),
                    rgba(200, 150, 30, 1));
            position: relative;
        }

        .icon-btn .button-inner span {
            font-size: 1rem;
            font-weight: bold;
            color: rgba(0, 0, 0, 0);
            background-image: linear-gradient(135deg,
                    rgba(255, 255, 200, 1),
                    rgba(255, 255, 255, 1));
            -webkit-background-clip: text;
            background-clip: text;
        }

        /* Add horns to icon buttons */
        .icon-btn .button-inner::before,
        .icon-btn .button-inner::after {
            content: "";
            position: absolute;
            top: -10px;
            width: 10px;
            height: 15px;
            background-color: #8a7a2a;
            border-radius: 5px 5px 0 0;
            z-index: 5;
            transform: rotate(-15deg);
        }

        button:hover .button-inner span {
            transform: scale(0.975);
        }

        button:active .button-inner {
            transform: scale(0.975);
        }

        /* تنسيق للعنصر المخفي الذي يحتوي على النص المراد نسخه */
        #copy-text {
            position: absolute;
            left: -9999px;
            top: -9999px;
            opacity: 0;
        }

        /* تنسيق لإشعار النسخ */
        #copy-notification {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            pointer-events: none;
        }

        #copy-notification.show {
            opacity: 1;
        }

        /* تنسيق زر التحكم بالصوت */
        #sound-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 1000;
            color: white;
            font-size: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        #sound-button:hover {
            background-color: rgba(50, 50, 50, 0.7);
            transform: scale(1.1);
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <div id="logo">
        <h1>bort</h1>
    </div>

    <!-- إضافة مشغل الصوت بحيث يعمل تلقائياً -->
    <audio id="background-music" autoplay loop>
        <source src="Ethereal.m4a" type="audio/mp4">
        لا يدعم متصفحك عنصر الصوت.
    </audio>

    <!-- زر التحكم بالصوت -->
    <div id="sound-button">🔊</div>

    <div id="button-container">
        <button id="copy-button">
            <div class="button-outer">
                <div class="button-inner">
                    <span>8ZtvqXDALSEQ2MXofQNKeRtyhMsjLAptDMhPyJxsbonk</span>
                </div>
            </div>
        </button>

        <div id="icons-container">
            <button class="icon-btn"
                onclick="window.open('https://dexscreener.com/solana/8ZtvqXDALSEQ2MXofQNKeRtyhMsjLAptDMhPyJxsbonk', '_blank')">
                <div class="button-outer">
                    <div class="button-inner">
                        <span>DEX</span>
                    </div>
                </div>
            </button>

            <button class="icon-btn" onclick="window.open('https://x.com/bortcto', '_blank')">
                <div class="button-outer">
                    <div class="button-inner">
                        <span>X</span>
                    </div>
                </div>
            </button>

            <button class="icon-btn" onclick="window.open('https://x.com/i/communities/1922103377204257032', '_blank')">
                <div class="button-outer">
                    <div class="button-inner">
                        <span>community</span>
                    </div>
                </div>
            </button>

            <button class="icon-btn"
                onclick="window.open('https://jup.ag/swap/SOL-8ZtvqXDALSEQ2MXofQNKeRtyhMsjLAptDMhPyJxsbonk', '_blank')">
                <div class="button-outer">
                    <div class="button-inner">
                        <span>BUY</span>
                    </div>
                </div>
            </button>
        </div>
    </div>

    <!-- إضافة عنصر مخفي لتسهيل عملية النسخ -->
    <textarea id="copy-text">8ZtvqXDALSEQ2MXofQNKeRtyhMsjLAptDMhPyJxsbonk</textarea>

    <!-- إضافة عنصر لإظهار إشعار النسخ -->
    <div id="copy-notification"> COPY!</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        // إعداد المشهد والكاميرا والعارض
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);

        // إعداد العارض مع تحسين الأداء
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.physicallyCorrectLights = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('container').appendChild(renderer.domElement);

        // إضاءة قوية جداً - جعلها متوسطة بين السابقة والحالية
        const ambientLight = new THREE.AmbientLight(0xffffff, 8.5);
        scene.add(ambientLight);

        // إضافة عدة مصادر إضاءة من جميع الاتجاهات
        function addDirectionalLight(x, y, z, intensity, color = 0xffffff) {
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(x, y, z);
            scene.add(light);
            return light;
        }

        // إضاءات من جميع الاتجاهات مع قيم متوسطة
        addDirectionalLight(5, 5, 5, 10.0);
        addDirectionalLight(-5, 5, -5, 8.0);
        addDirectionalLight(0, -5, 0, 6.0);
        addDirectionalLight(5, 0, -5, 5.0, 0xffdddd);

        // إضافة إضاءات إضافية بقيم متوسطة
        addDirectionalLight(-5, 0, 5, 4.5, 0xddffdd);
        addDirectionalLight(0, 5, 0, 7.0, 0xffffff);

        // الإبقاء على إضاءة واحدة فقط من الإضاءات الإضافية الجديدة بشدة أقل
        addDirectionalLight(3, 3, 3, 3.0, 0xffffee);

        // إضافة إضاءة نقطية في المركز بقيمة متوسطة
        const pointLight = new THREE.PointLight(0xffffff, 8.0, 25);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        // إضافة إضاءة نقطية ثانية للتأكيد بقيمة متوسطة
        const pointLight2 = new THREE.PointLight(0xffffdd, 6.0, 20);
        pointLight2.position.set(0, 3, 0);
        scene.add(pointLight2);

        // الإبقاء على إضاءة نقطية ثالثة بشدة أقل
        const pointLight3 = new THREE.PointLight(0xddffff, 5.0, 20);
        pointLight3.position.set(0, -3, 0);
        scene.add(pointLight3);

        // الإبقاء على إضاءة مسرحية واحدة فقط بشدة متوسطة
        const spotLight1 = new THREE.SpotLight(0xffffff, 10.0, 50, Math.PI / 6, 0.5, 2);
        spotLight1.position.set(10, 10, 10);
        spotLight1.lookAt(0, 0, 0);
        scene.add(spotLight1);

        // إضافة تحكم بالدوران
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.8;
        controls.zoomSpeed = 1.2;

        // متغير للتحكم بالتدوير التلقائي - تم تعطيله ليدور فقط عندما يدوره المستخدم
        let autoRotate = false;

        // تحميل المجسم ثلاثي الأبعاد
        const loader = new THREE.GLTFLoader();
        let model;
        let modelHead; // إضافة متغير للرأس تحديداً

        // إضافة التدوير التلقائي
        let rotationSpeed = 0.005;

        // متغيرات للتحكم في حركة الاهتزاز المكهرب
        let originalPosition = new THREE.Vector3();
        let originalRotation = new THREE.Euler();

        // معلمات الاهتزاز المكهرب
        const electricVibration = {
            enabled: false,  // تعطيل الاهتزاز
            positionIntensity: 0.1,  // شدة الاهتزاز في الموضع (زيادة من 0.05 إلى 0.15)
            rotationIntensity: 0.05,  // شدة الاهتزاز في الدوران (زيادة من 0.035 إلى 0.08)

            // تردد الاهتزاز (بالهرتز) - ترددات عالية جداً
            xFrequency: 35.7,  // تردد سريع جداً للمحور X
            yFrequency: 40.3,  // تردد أسرع للمحور Y
            zFrequency: 38.1,  // تردد سريع للمحور Z

            // تردد الدوران - ترددات عالية
            rotXFrequency: 32.9,  // تردد الدوران حول X
            rotYFrequency: 30.7,  // تردد الدوران حول Y
            rotZFrequency: 28.3    // تردد الدوران حول Z
        };

        // إنشاء ساعة لتتبع الوقت
        let clock = new THREE.Clock();

        // متغيرات جديدة للقفز عند النقر
        let isClickJumping = false;
        let clickJumpStartTime = 0;
        let clickJumpDuration = 2.0; // مدة قفزة أبطأ (كانت 1.5)
        let clickRotationDuration = 2.5; // مدة دوران أبطأ (كانت 1.5)
        let modelInitialY = 0; // سيتم تحديثه عند تحميل النموذج
        let headInitialY = 0; // سيتم تحديثه عند تحديد الرأس
        let headInitialRotation = new THREE.Euler(); // للحفاظ على دوران الرأس الأصلي

        // هذه الوظيفة تقوم بحساب حركة الاهتزاز المكهرب
        function applyElectricVibration(obj, time) {
            if (!electricVibration.enabled) return;

            // إضافة اهتزاز للموضع - استخدام دالة الجيب للحصول على حركة تذبذبية
            obj.position.x = originalPosition.x + Math.sin(time * electricVibration.xFrequency) * electricVibration.positionIntensity;
            obj.position.y = originalPosition.y + Math.sin(time * electricVibration.yFrequency) * electricVibration.positionIntensity;
            obj.position.z = originalPosition.z + Math.sin(time * electricVibration.zFrequency) * electricVibration.positionIntensity;

            // إضافة اهتزاز للدوران
            obj.rotation.x = originalRotation.x + Math.sin(time * electricVibration.rotXFrequency) * electricVibration.rotationIntensity;
            obj.rotation.y = originalRotation.y + Math.sin(time * electricVibration.rotYFrequency) * electricVibration.rotationIntensity;
            obj.rotation.z = originalRotation.z + Math.sin(time * electricVibration.rotZFrequency) * electricVibration.rotationIntensity;

            // إضافة حركة عشوائية مفاجئة بين الحين والآخر لمحاكاة الصدمات الكهربائية
            if (Math.random() < 0.1) { // احتمال 10% لحدوث صدمة كهربائية في كل إطار
                const joltDirection = Math.random() > 0.5 ? 1 : -1;
                const joltAmount = 0.2; // شدة أكبر للصدمة الكهربائية

                obj.position.x += joltDirection * joltAmount * Math.random();
                obj.position.y += joltDirection * joltAmount * Math.random();
                obj.rotation.z += joltDirection * 0.2 * Math.random();
            }
        }

        loader.load(
            'textured.glb',
            function (gltf) {
                model = gltf.scene;

                // تطبيق مواد متوهجة على المجسم بدرجة أقل
                model.traverse(function (child) {
                    if (child.isMesh) {
                        // زيادة سطوع وإضاءة المواد بدرجة متوسطة
                        if (child.material) {
                            // حفظ المادة الأصلية
                            const originalMaterial = child.material.clone();

                            // إضاءة متوسطة للمادة
                            child.material.emissive = new THREE.Color(0x222222);
                            child.material.emissiveIntensity = 0.3;

                            // انعكاسية متوسطة للمادة
                            if (child.material.metalness !== undefined) {
                                child.material.metalness = Math.min(child.material.metalness + 0.1, 1.0);
                            }

                            // لمعان متوسط للمادة
                            if (child.material.roughness !== undefined) {
                                child.material.roughness = Math.max(child.material.roughness - 0.2, 0.2);
                            }

                            child.material.needsUpdate = true;
                        }

                        // محاولة تحديد الرأس - البحث عن أسماء محتملة للرأس
                        if (child.name.toLowerCase().includes('head') ||
                            child.name.toLowerCase().includes('face') ||
                            child.name.toLowerCase().includes('skull') ||
                            child.name.toLowerCase().includes('رأس') ||
                            child.name.toLowerCase().includes('وجه')) {
                            modelHead = child;
                            console.log('تم العثور على الرأس:', child.name);
                        }
                    }
                });

                // إذا لم يتم العثور على جزء الرأس، حاول البحث عن أعلى جزء في النموذج
                if (!modelHead) {
                    console.log('لم يتم العثور على الرأس بالاسم، سنحاول تحديده بالموقع');

                    let highestY = -Infinity;
                    let smallestMesh = null;
                    let smallestVolume = Infinity;

                    model.traverse(function (child) {
                        if (child.isMesh) {
                            // حساب نقطة Y العليا للجسم
                            child.geometry.computeBoundingBox();
                            const box = child.geometry.boundingBox;
                            const topY = box.max.y;

                            // حساب حجم الجسم التقريبي
                            const size = new THREE.Vector3();
                            box.getSize(size);
                            const volume = size.x * size.y * size.z;

                            // تحقق مما إذا كان هذا المكون في الأعلى
                            if (topY > highestY) {
                                highestY = topY;
                                smallestMesh = child;
                                smallestVolume = volume;
                            }
                            // أو إذا كان على نفس الارتفاع تقريبًا ولكن أصغر (مثل الرأس)
                            else if (Math.abs(topY - highestY) < 0.1 && volume < smallestVolume) {
                                smallestMesh = child;
                                smallestVolume = volume;
                            }
                        }
                    });

                    if (smallestMesh) {
                        modelHead = smallestMesh;
                        console.log('تم تحديد الرأس بالموقع:', smallestMesh.name);
                    } else {
                        // في حالة الفشل، استخدم النموذج كاملاً
                        modelHead = model;
                        console.log('لم يتم العثور على الرأس، سيتم استخدام النموذج كاملاً');
                    }
                }

                // تكبير النموذج - 5 أضعاف الحجم الأصلي
                model.scale.set(5.0, 5.0, 5.0);

                // حساب مركز النموذج وتوسيطه
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());

                // توسيط النموذج وتحريكه قليلاً للأسفل
                model.position.x = -center.x;
                model.position.y = -center.y - 0.8;
                model.position.z = -center.z;

                // ضبط النموذج ليكون مستقيماً تماماً كما في الصورة المرجعية
                model.rotation.set(0, 0, 0);

                // تعديل موضع النموذج ليتطابق مع الصورة - خفض الموضع قليلاً
                model.position.y += 0.15; // تم تقليل القيمة من 0.3 إلى 0.15 لإنزاله قليلاً

                // حفظ الدوران الأصلي للرأس منفصلاً إذا تم تحديده
                if (modelHead && modelHead !== model) {
                    // إجبار الرأس على البقاء مستقيماً
                    modelHead.rotation.set(0, 0, 0);
                    modelHead.originalRotation = modelHead.rotation.clone();
                }

                // حفظ الموضع والدوران الأصلي للاهتزاز
                originalPosition.copy(model.position);
                originalRotation.copy(model.rotation);

                // حفظ الموضع الأصلي للنموذج لاستخدامه في القفز
                modelInitialY = model.position.y;

                // حفظ الموضع الأصلي للرأس إذا تم العثور عليه
                if (modelHead && modelHead !== model) {
                    headInitialY = modelHead.position.y;
                    headInitialRotation.copy(modelHead.rotation); // حفظ دوران الرأس الأصلي
                }

                // إضافة النموذج للمشهد
                scene.add(model);

                // إضافة استجابة للنقر على النموذج - تسجيل مستمع خارجي للصفحة كاملة
                document.addEventListener('click', handleModelClick);

                // ضبط موضع الكاميرا لتكون مشابهة للصورة المرجعية
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(0, 0, maxDim * 1.3); // تقريب الكاميرا قليلاً
                camera.lookAt(0, -0.5, 0); // تعديل نقطة النظر للأعلى قليلاً

                // تحديث التحكم
                controls.target.set(0, -0.5, 0);
                controls.update();
            },
            function (xhr) {
                // تمت إزالة رسائل التحميل
            },
            function (error) {
                console.error('حدث خطأ أثناء تحميل المجسم:', error);
            }
        );

        // تحديث الحجم عند تغيير أبعاد النافذة
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // إضافة متغيرات لتتبع مؤشر الماوس
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let lookAtPoint = new THREE.Vector3();
        let followMouse = true; // تمكين تتبع المؤشر
        let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -10); // مستوى افتراضي للتقاطع مع المؤشر

        // إضافة مستمع لتتبع حركة المؤشر
        document.addEventListener('mousemove', function (event) {
            // تحويل موقع المؤشر إلى نطاق -1 إلى 1
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1; // قلب العلامة لتنسيق ثري جي إس

            // تحديث المُشعاع
            raycaster.setFromCamera(mouse, camera);

            // حساب نقطة التقاطع مع المستوى
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectPoint);

            // تحديث نقطة النظر
            lookAtPoint.copy(intersectPoint);
        });

        // متغيرات للتحكم في حركة القفز
        let isJumping = true; // تفعيل القفز البطيء
        let jumpSpeed = 1.2; // سرعة عالية جداً (كانت 0.8)
        let jumpHeight = 0.3; // تقليل الارتفاع أكثر (كان 0.5)

        // حلقة الرسم
        function animate() {
            requestAnimationFrame(animate);

            // الحصول على الوقت المنقضي منذ بدء التشغيل
            const time = clock.getElapsedTime();

            // إضافة حركة قفز بطيئة - فقط إذا لم يكن في وضع القفز بالنقر
            if (model && isJumping && !isClickJumping) {
                // استخدام دالة مخصصة للحصول على حركة طفو مع توقف قصير في الأعلى والأسفل
                let wave = Math.sin(time * jumpSpeed);

                // تطبيق معادلة لجعل الحركة تبقى لفترة أطول في الأعلى وفي الأسفل
                wave = Math.sign(wave) * Math.pow(Math.abs(wave), 0.7);

                const jumpOffset = wave * jumpHeight;

                // تطبيق حركة القفز على موضع النموذج
                model.position.y = originalPosition.y + jumpOffset;
            }

            // تنفيذ قفزة عند النقر على النموذج
            if (model && isClickJumping) {
                // حساب المدة المنقضية منذ بدء القفزة
                const jumpElapsed = time - clickJumpStartTime;

                // التحقق من أن القفزة لم تنته بعد
                if (jumpElapsed < clickJumpDuration + clickRotationDuration) {
                    // مرحلة القفز
                    if (jumpElapsed < clickJumpDuration) {
                        // استخدام دالة تربيعية للقفز ثم العودة
                        const progress = jumpElapsed / clickJumpDuration;
                        const jumpHeight = 2.0; // ارتفاع قفزة أكبر

                        // قفزة على شكل منحنى قطعي (بارابولا)
                        const jumpOffset = jumpHeight * 4 * progress * (1 - progress);

                        // تطبيق القفزة على النموذج
                        model.position.y = modelInitialY + jumpOffset;

                        // إلغاء حركة الرأس المنفصلة وجعله يتحرك مع النموذج
                        if (modelHead && modelHead !== model) {
                            // تأكد من أن الرأس لا يتحرك بشكل منفصل عن الجسم
                            modelHead.position.y = headInitialY; // إبقاء موضع الرأس النسبي كما هو بالنسبة للنموذج
                        }
                    }

                    // مرحلة الدوران - تطبيق فقط على الرأس الآن
                    if (modelHead && modelHead !== model) {
                        const rotationProgress = (Math.min(jumpElapsed, clickRotationDuration) / clickRotationDuration);

                        // دوران كامل (360 درجة) حول المحور Y
                        const fullRotation = Math.PI * 2;
                        // استخدام دالة الجيب لجعل الدوران أكثر سلاسة
                        const rotationOffset = fullRotation * Math.sin(rotationProgress * Math.PI);

                        // تطبيق الدوران على الرأس فقط - حفظ قيم الدوران الأخرى
                        modelHead.rotation.x = headInitialRotation.x;
                        modelHead.rotation.y = headInitialRotation.y + rotationOffset;
                        modelHead.rotation.z = headInitialRotation.z;
                    }

                    // النموذج الرئيسي لا يدور بعد الآن
                    model.rotation.y = originalRotation.y;
                } else {
                    // انتهت القفزة، إعادة كل شيء إلى الوضع الأصلي
                    isClickJumping = false;

                    // إعادة النموذج إلى وضعه الأصلي
                    model.position.y = modelInitialY;

                    // إعادة الرأس إلى وضعه الأصلي
                    if (modelHead && modelHead !== model) {
                        modelHead.position.y = headInitialY;
                        modelHead.rotation.copy(headInitialRotation);
                    }
                }
            }

            // تحريك الرأس لتتبع المؤشر بشكل طبيعي - يميل للأمام أو الخلف حسب موضع المؤشر
            if (followMouse && modelHead && modelHead !== model) {
                // الحصول على موضع الرأس العالمي
                const headWorldPos = new THREE.Vector3();
                modelHead.getWorldPosition(headWorldPos);

                // تحديد معلمات الحركة - نعيد فعّال حركة الرأس الرأسية (أعلى/أسفل)
                const maxRotationX = 0.4; // حد دوران المحور X (أعلى/أسفل)
                const maxRotationY = 0.6; // حد دوران المحور Y (يمين/يسار)
                const smoothFactor = 0.15; // معامل النعومة للاستجابة

                // إنشاء كائن مؤقت لحساب الدوران المستهدف
                const tempObj = new THREE.Object3D();
                tempObj.position.copy(headWorldPos);
                tempObj.lookAt(lookAtPoint);

                // استخراج الزوايا - نهتم الآن بكلا المحورين X و Y
                const targetRot = new THREE.Euler().setFromQuaternion(tempObj.quaternion);
                const currentRot = modelHead.rotation.clone();

                // حساب مقدار دوران المحور X (أعلى/أسفل) بناءً على موضع المؤشر
                // استخدام موضع المؤشر مباشرة للتحكم في دوران الرأس
                let targetX = 0;

                // إذا كان المؤشر في الأعلى، يميل الرأس للخلف (دوران سالب حول المحور X)
                if (mouse.y > 0) {
                    targetX = -maxRotationX * Math.min(mouse.y, 1.0); // ميل للخلف عند رفع المؤشر
                }
                // إذا كان المؤشر في الأسفل، يميل الرأس للأمام (دوران موجب حول المحور X)
                else if (mouse.y < 0) {
                    targetX = maxRotationX * Math.min(Math.abs(mouse.y), 1.0); // ميل للأمام عند خفض المؤشر
                }

                // حساب الفرق بين الوضع الحالي والوضع المستهدف للمحور X
                const xDiff = targetX - currentRot.x;

                // حساب الحركة الأفقية (يمين/يسار) باستخدام الدوران المحسوب من tempObj
                const yDiff = THREE.MathUtils.clamp(
                    targetRot.y - currentRot.y,
                    -maxRotationY, // حركة متساوية في كلا الاتجاهين الجانبيين
                    maxRotationY
                );

                // تطبيق التغييرات على دوران الرأس
                modelHead.rotation.x += xDiff * smoothFactor;
                modelHead.rotation.y += yDiff * smoothFactor;

                // تقييد دوران محور X ضمن الحدود المعقولة
                modelHead.rotation.x = THREE.MathUtils.clamp(
                    modelHead.rotation.x,
                    -maxRotationX, // الحد الأقصى للخلف
                    maxRotationX  // الحد الأقصى للأمام
                );
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // إضافة وظيفة نسخ النص - استخدام Clipboard API الحديثة
        document.getElementById('copy-button').addEventListener('click', function (e) {
            console.log("تم النقر على زر النسخ");
            e.stopPropagation();

            const textToCopy = "8ZtvqXDALSEQ2MXofQNKeRtyhMsjLAptDMhPyJxsbonk";

            // استخدام Clipboard API الحديثة
            if (navigator.clipboard) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => {
                        // إظهار إشعار النسخ
                        const notification = document.getElementById('copy-notification');
                        notification.classList.add('show');

                        // إخفاء الإشعار بعد ثانيتين
                        setTimeout(function () {
                            notification.classList.remove('show');
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('فشل في نسخ النص: ', err);
                    });
            } else {
                // طريقة احتياطية للمتصفحات القديمة
                const textArea = document.getElementById('copy-text');
                textArea.value = textToCopy;
                textArea.focus();
                textArea.select();

                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        const notification = document.getElementById('copy-notification');
                        notification.classList.add('show');
                        setTimeout(function () {
                            notification.classList.remove('show');
                        }, 2000);
                    }
                } catch (err) {
                    console.error('فشل في نسخ النص: ', err);
                }
            }
        });

        // إضافة مستمعي أحداث للأزرار الأخرى للتأكد من عملها
        document.querySelectorAll('.icon-btn').forEach(function (button, index) {
            button.addEventListener('click', function (e) {
                console.log("تم النقر على زر الأيقونة رقم:", index + 1);
                e.stopPropagation();
            });
        });

        // إضافة تحكم عبر لوحة المفاتيح
        document.addEventListener('keydown', function (event) {
            // اضغط على مفتاح E للتبديل بين تشغيل/إيقاف حركة الاهتزاز المكهرب
            if (event.key === 'e' || event.key === 'E') {
                electricVibration.enabled = !electricVibration.enabled;

                // إعادة الموضع الأصلي عند إيقاف الاهتزاز
                if (!electricVibration.enabled && model) {
                    model.position.copy(originalPosition);
                    model.rotation.copy(originalRotation);

                    // إعادة الرأس إلى وضعه الأصلي أيضاً
                    if (modelHead && modelHead !== model && modelHead.originalRotation) {
                        modelHead.rotation.copy(modelHead.originalRotation);
                    }
                }
            }

            // اضغط على مفتاح F للتبديل بين تشغيل/إيقاف تتبع المؤشر
            if (event.key === 'f' || event.key === 'F') {
                followMouse = !followMouse;
                console.log(followMouse ? 'تم تفعيل تتبع المؤشر' : 'تم إيقاف تتبع المؤشر');

                // إعادة الرأس إلى وضعه الأصلي عند إيقاف التتبع
                if (!followMouse && modelHead && modelHead !== model && modelHead.originalRotation) {
                    modelHead.rotation.copy(modelHead.originalRotation);
                }
            }

            // اضغط على مفتاح J للتبديل بين تشغيل/إيقاف حركة القفز
            if (event.key === 'j' || event.key === 'J') {
                isJumping = !isJumping;
                console.log(isJumping ? 'تم تفعيل حركة القفز' : 'تم إيقاف حركة القفز');

                // إعادة النموذج إلى موضعه الأصلي عند إيقاف القفز
                if (!isJumping && model) {
                    model.position.y = originalPosition.y;
                }
            }
        });

        // تعريف وظيفة التعامل مع النقر على النموذج
        function handleModelClick(event) {
            // التحقق من وجود النموذج
            if (!model) return;

            // تحويل إحداثيات النقر إلى نطاق -1 إلى 1
            const clickMouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );

            // استخدام الراكستر للتحقق من وقوع النقر على النموذج
            raycaster.setFromCamera(clickMouse, camera);
            const intersects = raycaster.intersectObject(model, true);

            // إذا تم النقر على النموذج، نبدأ القفز
            if (intersects.length > 0) {
                // طباعة تشخيصية للتأكد من حدوث النقر
                console.log("تم النقر على النموذج!");

                // منع تكرار القفز أثناء قفزة حالية
                if (!isClickJumping) {
                    isClickJumping = true;
                    clickJumpStartTime = clock.getElapsedTime(); // استخدام الساعة مباشرة
                    console.log("تم بدء القفزة عند الوقت:", clickJumpStartTime);
                }
            } else {
                console.log("النقر خارج النموذج");
            }
        }

        animate();

        // إضافة التحكم بالصوت
        const backgroundMusic = document.getElementById('background-music');
        const soundButton = document.getElementById('sound-button');
        let isMuted = false;

        // ضبط مستوى الصوت المبدئي
        backgroundMusic.volume = 0.5;

        // التأكد من تشغيل الموسيقى بعد تفاعل المستخدم (ضروري في بعض المتصفحات)
        document.addEventListener('click', function () {
            backgroundMusic.play().catch(error => {
                console.log("تعذر تشغيل الموسيقى تلقائياً، يرجى النقر مرة أخرى");
            });
        }, { once: true });

        // إضافة وظيفة التبديل بين كتم وتشغيل الصوت
        soundButton.addEventListener('click', function () {
            isMuted = !isMuted;
            backgroundMusic.muted = isMuted;
            soundButton.textContent = isMuted ? '🔇' : '🔊';
        });
    </script>
</body>

</html>